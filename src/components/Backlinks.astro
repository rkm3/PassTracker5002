---
import fs from 'fs/promises';
import path from 'path';
const baseUrl = import.meta.env.BASE_URL;

// Define the structure we expect in the JSON
interface BacklinkEntry {
  url: string;
  title: string;
}

interface Props {
  pathname: string; // Expecting Astro.url.pathname
}

const { pathname } = Astro.props;

// Helper to normalize the current page's pathname
const normalizeUrlPath = (rawPathname: string, basePath: string): string => {
    let normalized = rawPathname;
    const base = basePath.endsWith('/') ? basePath : basePath + '/';

    if (base !== '/' && normalized.startsWith(base)) {
        normalized = normalized.substring(base.length - 1);
         if (!normalized.startsWith('/')) normalized = '/' + normalized;
    }
    try {
        normalized = decodeURI(normalized);
    } catch (e) {
        console.warn(`[Backlinks Component] Failed to decode URI: ${rawPathname}`, e);
    }
    if (normalized.length > 1 && normalized.endsWith('/')) {
        normalized = normalized.slice(0, -1);
    }
     if (!normalized.startsWith('/')) normalized = '/' + normalized;
    return normalized;
};

// Helper to determine the type of backlink based on URL
const getBacklinkType = (url: string): string => {
    if (url.startsWith('/owners/')) return 'Owners';
    if (url.startsWith('/ski-areas/')) return 'Ski Areas';
    // Check for seasonal passes first
    if (url.startsWith('/passes/2024-25/')) return 'Passes 2024-25';
    if (url.startsWith('/passes/2025-26/')) return 'Passes 2025-26';
    // Generic passes fallback
    if (url.startsWith('/passes/')) return 'Passes';
    if (url.startsWith('/posts/')) return 'Storm Posts';
    if (url.startsWith('/countries/')) return 'Countries';
    // Add other known prefixes here
    return 'Other Pages'; // Default category
};

// Read the backlinks data dynamically from the project root
let referringPages: readonly BacklinkEntry[] = [];
let backlinksData: Record<string, BacklinkEntry[]> | null = null;
const projectRoot = process.cwd();
const backlinksFilePath = path.join(projectRoot, 'src', 'data', 'backlinks.json');
const postPubDatesFilePath = path.join(projectRoot, 'src', 'data', 'postPubDates.json'); // Path to the new JSON
let postPubDates: Record<string, string> = {}; // Map to store URL -> pubDate

// Load Backlinks Data
try {
    // Check if file exists before trying to read
    try {
        await fs.access(backlinksFilePath); // Check existence at src/data/backlinks.json
        const backlinksJsonContent = await fs.readFile(backlinksFilePath, 'utf-8');
        backlinksData = JSON.parse(backlinksJsonContent);
    } catch (existenceError: any) { // Catch potential errors
        if (existenceError.code === 'ENOENT') {
             console.warn(`[Backlinks Component] backlinks.json not found at ${backlinksFilePath}. This might be expected during the build.`);
        } else {
            // Re-throw unexpected errors (e.g., permissions)
            throw existenceError;
        }
    }

    if (backlinksData) {
        const canonicalUrl = normalizeUrlPath(pathname, baseUrl);
        const entries = backlinksData[canonicalUrl];
        if (Array.isArray(entries) && entries.every(e => typeof e === 'object' && e !== null && 'url' in e && 'title' in e)) {
             referringPages = entries;
        } else if (entries !== undefined) {
             console.warn(`[Backlinks Component] backlinks.json data for ${canonicalUrl} has unexpected format. Expected array of {url, title}. Found:`, entries);
        }
    }
} catch (error) {
    console.error('[Backlinks Component] Error processing backlinks data:', error);
}

// Load Post Publication Dates
try {
    await fs.access(postPubDatesFilePath);
    const pubDatesJsonContent = await fs.readFile(postPubDatesFilePath, 'utf-8');
    postPubDates = JSON.parse(pubDatesJsonContent);
} catch (error: any) {
    if (error.code === 'ENOENT') {
        console.warn(`[Backlinks Component] postPubDates.json not found at ${postPubDatesFilePath}. Skipping pub date display.`);
    } else {
        console.error('[Backlinks Component] Error reading or parsing postPubDates.json:', error);
    }
    postPubDates = {}; // Ensure it's an empty object on error
}


// Group backlinks by type
const groupedBacklinks: Record<string, BacklinkEntry[]> = {};
for (const entry of referringPages) {
    const type = getBacklinkType(entry.url);
    if (!groupedBacklinks[type]) {
        groupedBacklinks[type] = [];
    }
    groupedBacklinks[type].push(entry);
}

// Define preferred order for sections
const typeOrder = ['Storm Posts', 'Passes', 'Passes 2025-26', 'Passes 2024-25', 'Owners', 'Ski Areas', 'Other Pages']; // Added seasonal passes

// Sort the grouped backlinks based on the preferred order
const sortedGroupedBacklinks = Object.entries(groupedBacklinks).sort(([typeA], [typeB]) => {
    const indexA = typeOrder.indexOf(typeA);
    const indexB = typeOrder.indexOf(typeB);
    // Handle types not in the predefined order (place them at the end)
    if (indexA === -1 && indexB === -1) return typeA.localeCompare(typeB); // Sort alphabetically if both unknown
    if (indexA === -1) return 1; // Place unknown types after known types
    if (indexB === -1) return -1; // Place known types before unknown types
    return indexA - indexB; // Sort based on predefined order
});


const baseHref = baseUrl.endsWith('/') ? baseUrl : baseUrl + '/';
const showBacklinks = sortedGroupedBacklinks.length > 0;

// Helper function to format date string (YYYY-MM-DDTHH:mm:ss.sssZ) to YYYY-MM-DD
const formatDate = (dateString: string | undefined): string | null => {
    if (!dateString) return null;
    try {
        const date = new Date(dateString);
        // Check if date is valid after parsing
        if (isNaN(date.getTime())) {
            console.warn(`[Backlinks Component] Invalid date format encountered: ${dateString}`);
            return null; // Return null for invalid dates
        }
        // Format to YYYY-MM-DD. Adding 1 to month because getMonth() is 0-indexed.
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
    } catch (e) {
        console.error(`[Backlinks Component] Error formatting date: ${dateString}`, e);
        return null; // Return null on formatting error
    }
};

---
{showBacklinks && (
  <div class="mt-12 pt-8 border-t border-gray-200">
    <h2 class="text-2xl font-semibold mb-6">Links to this Page</h2>
    {/* Wrap the mapped sections in a grid container */}
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
      {sortedGroupedBacklinks.map(([type, entries]) => (
        <div class="mb-6"> {/* Removed last:mb-0 as grid gap handles spacing */}
          <h3 class="text-xl font-medium mb-3">{type} ({entries.length})</h3> {/* Show count */}
          <ul class="list-disc list-inside space-y-2">
            {entries.map((entry: BacklinkEntry) => {
              const isPost = entry.url.startsWith('/posts/');
              const pubDate = isPost ? postPubDates[entry.url] : undefined;
              const formattedDate = formatDate(pubDate);
              return (
                <li>
                  <a href={`${baseHref}${entry.url.startsWith('/') ? entry.url.substring(1) : entry.url}`} class="text-blue-600 hover:underline">{entry.title}</a>
                  {/* Display formatted date if it exists */}
                  {formattedDate && (
                    <span class="text-sm text-gray-500 ml-2">{formattedDate}</span>
                  )}
                </li>
              );
            })}
          </ul>
        </div>
      ))}
    </div> {/* Close grid container */}
  </div>
)}