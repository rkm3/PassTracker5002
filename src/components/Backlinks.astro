---
import fs from 'fs/promises';
import path from 'path';
const baseUrl = import.meta.env.BASE_URL;

// Define the structure we expect in the JSON
interface BacklinkEntry {
  url: string;
  title: string;
}

interface Props {
  pathname: string; // Expecting Astro.url.pathname
}

const { pathname } = Astro.props;

// Helper to normalize the current page's pathname
const normalizeUrlPath = (rawPathname: string, basePath: string): string => {
    let normalized = rawPathname;
    const base = basePath.endsWith('/') ? basePath : basePath + '/';

    if (base !== '/' && normalized.startsWith(base)) {
        normalized = normalized.substring(base.length - 1);
         if (!normalized.startsWith('/')) normalized = '/' + normalized;
    }
    try {
        normalized = decodeURI(normalized);
    } catch (e) {
        console.warn(`[Backlinks Component] Failed to decode URI: ${rawPathname}`, e);
    }
    if (normalized.length > 1 && normalized.endsWith('/')) {
        normalized = normalized.slice(0, -1);
    }
     if (!normalized.startsWith('/')) normalized = '/' + normalized;
    return normalized;
};

// Helper to determine the type of backlink based on URL
const getBacklinkType = (url: string): string => {
    if (url.startsWith('/owners/')) return 'Owners';
    if (url.startsWith('/ski-areas/')) return 'Ski Areas';
    if (url.startsWith('/passes/')) return 'Passes';
    if (url.startsWith('/posts/')) return 'Storm Posts';
    if (url.startsWith('/countries/')) return 'Countries';
    // Add other known prefixes here
    return 'Other Pages'; // Default category
};

// Read the backlinks data dynamically from the project root
let referringPages: readonly BacklinkEntry[] = [];
let backlinksData: Record<string, BacklinkEntry[]> | null = null;
const projectRoot = process.cwd();
const backlinksFilePath = path.join(projectRoot, 'src', 'data', 'backlinks.json');

try {
    // Check if file exists before trying to read
    try {
        await fs.access(backlinksFilePath); // Check existence at src/data/backlinks.json
        const backlinksJsonContent = await fs.readFile(backlinksFilePath, 'utf-8');
        backlinksData = JSON.parse(backlinksJsonContent);
    } catch (existenceError: any) { // Catch potential errors
        if (existenceError.code === 'ENOENT') {
             console.warn(`[Backlinks Component] backlinks.json not found at ${backlinksFilePath}. This might be expected during the build.`);
        } else {
            // Re-throw unexpected errors (e.g., permissions)
            throw existenceError;
        }
    }

    if (backlinksData) {
        const canonicalUrl = normalizeUrlPath(pathname, baseUrl);
        const entries = backlinksData[canonicalUrl];
        if (Array.isArray(entries) && entries.every(e => typeof e === 'object' && e !== null && 'url' in e && 'title' in e)) {
             referringPages = entries;
        } else if (entries !== undefined) {
             console.warn(`[Backlinks Component] backlinks.json data for ${canonicalUrl} has unexpected format. Expected array of {url, title}. Found:`, entries);
        }
    }
} catch (error) {
    console.error('[Backlinks Component] Error processing backlinks data:', error);
}

// Group backlinks by type
const groupedBacklinks: Record<string, BacklinkEntry[]> = {};
for (const entry of referringPages) {
    const type = getBacklinkType(entry.url);
    if (!groupedBacklinks[type]) {
        groupedBacklinks[type] = [];
    }
    groupedBacklinks[type].push(entry);
}

// Define preferred order for sections
const typeOrder = ['Owners', 'Ski Areas', 'Passes', 'Blog Posts', 'Other Pages'];

// Sort the grouped backlinks based on the preferred order
const sortedGroupedBacklinks = Object.entries(groupedBacklinks).sort(([typeA], [typeB]) => {
    const indexA = typeOrder.indexOf(typeA);
    const indexB = typeOrder.indexOf(typeB);
    // Handle types not in the predefined order (place them at the end)
    if (indexA === -1 && indexB === -1) return typeA.localeCompare(typeB); // Sort alphabetically if both unknown
    if (indexA === -1) return 1; // Place unknown types after known types
    if (indexB === -1) return -1; // Place known types before unknown types
    return indexA - indexB; // Sort based on predefined order
});


const baseHref = baseUrl.endsWith('/') ? baseUrl : baseUrl + '/';
const showBacklinks = sortedGroupedBacklinks.length > 0;
---
{showBacklinks && (
  <div class="mt-12 pt-8 border-t border-gray-200">
    <h2 class="text-2xl font-semibold mb-6">Links to this Page</h2>
    {sortedGroupedBacklinks.map(([type, entries]) => (
      <div class="mb-6 last:mb-0"> {/* Add margin between sections */}
        <h3 class="text-xl font-medium mb-3">{type} ({entries.length})</h3> {/* Show count */}
        <ul class="list-disc list-inside space-y-2">
          {entries.map((entry: BacklinkEntry) => (
            <li>
              <a href={`${baseHref}${entry.url.startsWith('/') ? entry.url.substring(1) : entry.url}`} class="text-blue-600 hover:underline">{entry.title}</a>
            </li>
          ))}
        </ul>
      </div>
    ))}
  </div>
)}